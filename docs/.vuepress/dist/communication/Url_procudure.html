<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>输入URL到页面加载的过程 | aurora blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/feature_cat.jpeg">
    <meta name="description" content="我的个人网站">
    
    <link rel="preload" href="/assets/css/0.styles.cb058343.css" as="style"><link rel="preload" href="/assets/js/app.157a43b5.js" as="script"><link rel="preload" href="/assets/js/2.52866a67.js" as="script"><link rel="preload" href="/assets/js/6.f0062c90.js" as="script"><link rel="prefetch" href="/assets/js/10.010d567c.js"><link rel="prefetch" href="/assets/js/11.4af4b929.js"><link rel="prefetch" href="/assets/js/12.337cdcf1.js"><link rel="prefetch" href="/assets/js/13.90875d56.js"><link rel="prefetch" href="/assets/js/14.0ed7aefb.js"><link rel="prefetch" href="/assets/js/15.754a382b.js"><link rel="prefetch" href="/assets/js/16.cb862ad8.js"><link rel="prefetch" href="/assets/js/17.4fa3dc3a.js"><link rel="prefetch" href="/assets/js/18.19362ae0.js"><link rel="prefetch" href="/assets/js/19.bb38661a.js"><link rel="prefetch" href="/assets/js/20.9f6dac92.js"><link rel="prefetch" href="/assets/js/21.b86ba564.js"><link rel="prefetch" href="/assets/js/22.08390e2a.js"><link rel="prefetch" href="/assets/js/23.07ce8733.js"><link rel="prefetch" href="/assets/js/24.2224abb3.js"><link rel="prefetch" href="/assets/js/25.cf2cacb2.js"><link rel="prefetch" href="/assets/js/26.0fab9c3d.js"><link rel="prefetch" href="/assets/js/27.409f3c11.js"><link rel="prefetch" href="/assets/js/28.2d999655.js"><link rel="prefetch" href="/assets/js/29.4c4b34f2.js"><link rel="prefetch" href="/assets/js/3.2452f598.js"><link rel="prefetch" href="/assets/js/30.c7e81ddc.js"><link rel="prefetch" href="/assets/js/31.87c49613.js"><link rel="prefetch" href="/assets/js/32.785f3b5f.js"><link rel="prefetch" href="/assets/js/33.d851ac79.js"><link rel="prefetch" href="/assets/js/34.f7dbbd6a.js"><link rel="prefetch" href="/assets/js/35.ecb758ea.js"><link rel="prefetch" href="/assets/js/36.478ee48d.js"><link rel="prefetch" href="/assets/js/37.b1e60efd.js"><link rel="prefetch" href="/assets/js/38.5b5e4eff.js"><link rel="prefetch" href="/assets/js/39.694373c0.js"><link rel="prefetch" href="/assets/js/4.e4d2375c.js"><link rel="prefetch" href="/assets/js/40.4a96b7b1.js"><link rel="prefetch" href="/assets/js/41.b0c17527.js"><link rel="prefetch" href="/assets/js/42.bb73ede6.js"><link rel="prefetch" href="/assets/js/43.dcd6c126.js"><link rel="prefetch" href="/assets/js/44.f643b2b9.js"><link rel="prefetch" href="/assets/js/45.194d68b8.js"><link rel="prefetch" href="/assets/js/46.a68230ef.js"><link rel="prefetch" href="/assets/js/47.0d19f838.js"><link rel="prefetch" href="/assets/js/48.d3f26e8c.js"><link rel="prefetch" href="/assets/js/49.b7740e4c.js"><link rel="prefetch" href="/assets/js/5.cb8c9fa9.js"><link rel="prefetch" href="/assets/js/50.2587ca2f.js"><link rel="prefetch" href="/assets/js/51.ea8d1c82.js"><link rel="prefetch" href="/assets/js/52.48ff45db.js"><link rel="prefetch" href="/assets/js/53.218b9ecf.js"><link rel="prefetch" href="/assets/js/54.1fa58f1d.js"><link rel="prefetch" href="/assets/js/55.d2ef0ce9.js"><link rel="prefetch" href="/assets/js/56.4a7bc600.js"><link rel="prefetch" href="/assets/js/57.b442bff3.js"><link rel="prefetch" href="/assets/js/58.542150a6.js"><link rel="prefetch" href="/assets/js/7.b156b7cb.js"><link rel="prefetch" href="/assets/js/8.dfb56ee2.js"><link rel="prefetch" href="/assets/js/9.f870735d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.cb058343.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">aurora blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/sountstars" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/sountstars" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JS</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/home.html" class="sidebar-link">基本汇总</a></li><li><a href="/js/date.html" class="sidebar-link">Date时间</a></li><li><a href="/js/array.html" class="sidebar-link">Array方法</a></li><li><a href="/js/string.html" class="sidebar-link">String 方法</a></li><li><a href="/js/object.html" class="sidebar-link">Object方法</a></li><li><a href="/js/regexp.html" class="sidebar-link">RegExp正则</a></li><li><a href="/js/feature.html" class="sidebar-link">Es6 新特性等</a></li><li><a href="/js/eventloop.html" class="sidebar-link">Event-Loop</a></li><li><a href="/js/http_https.html" class="sidebar-link">Http and Https</a></li><li><a href="/js/for_on_for_in.html" class="sidebar-link">for in和for of区别</a></li><li><a href="/js/web_worker.html" class="sidebar-link">Web Worker</a></li><li><a href="/js/promise.html" class="sidebar-link">Promise &amp;&amp; async</a></li><li><a href="/js/heap.html" class="sidebar-link">堆内存 &amp; 栈内存</a></li><li><a href="/js/design.html" class="sidebar-link">JS设计模式探索</a></li><li><a href="/js/npm_yarn.html" class="sidebar-link">npm &amp; yarn</a></li><li><a href="/js/fetch_axios.html" class="sidebar-link">Fetch和Axios的区别</a></li><li><a href="/js/interview.html" class="sidebar-link">学习及面试问题整理</a></li><li><a href="/js/url_process.html" class="sidebar-link">URL 输入到页面加载过程</a></li><li><a href="/js/proxy.html" class="sidebar-link">跨域&amp;nginx本地项目代理</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>FE框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>构建工具</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Typescript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Servers</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Git命令</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Other</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="输入url到页面加载的过程"><a href="#输入url到页面加载的过程" class="header-anchor">#</a> 输入URL到页面加载的过程</h1> <p></p><div class="table-of-contents"><ul><li><a href="#流程">流程</a></li><li><a href="#梳理主干流程">梳理主干流程</a></li><li><a href="#_1-从浏览器接收url到开启网络请求线程">1.从浏览器接收url到开启网络请求线程</a></li><li><a href="#_3-浏览器内核拿到内容后-渲染步骤大致">3.浏览器内核拿到内容后，渲染步骤大致</a></li><li><a href="#资源外链的下载">资源外链的下载</a></li><li><a href="#js引擎解析过程">JS引擎解析过程</a></li></ul></div><p></p> <h2 id="流程"><a href="#流程" class="header-anchor">#</a> 流程</h2> <div class="language-js extra-class"><pre class="language-js"><code>从浏览器接收url到开启网络请求线程 →→→ 开启网络线程到发出一个完整的http请求  →→→  服务器接收到请求到对应后台接收到请求
 →→→ 后台和前台的http交互 →→→ 单独拎出来的缓存问题，http的缓存 →→→ 解析页面流程 →→→ <span class="token constant">CSS</span>的可视化格式模型  →→→ 
<span class="token constant">JS</span>引擎解析过程
</code></pre></div><h2 id="梳理主干流程"><a href="#梳理主干流程" class="header-anchor">#</a> 梳理主干流程</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1.</span> 从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）
<span class="token number">2.</span> 开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp<span class="token operator">/</span>ip请求，五层因特网协议栈等知识）
<span class="token number">3.</span> 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）
<span class="token number">4.</span> 后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）
<span class="token number">5.</span> 单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch<span class="token operator">-</span>control等）
<span class="token number">6.</span> 浏览器接收到http数据包后的解析流程（解析html<span class="token operator">-</span>词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、<span class="token constant">GPU</span>绘制、外链资源的处理、loaded和domcontentloaded等）
<span class="token number">7.</span> <span class="token constant">CSS</span>的可视化格式模型（元素的渲染规则，如包含块，控制框，<span class="token constant">BFC</span>，<span class="token constant">IFC</span>等概念）
<span class="token number">8.</span> <span class="token constant">JS</span>引擎解析过程（<span class="token constant">JS</span>的解释阶段，预处理阶段，执行阶段生成执行上下文，<span class="token constant">VO</span>，作用域链、回收机制等等）
<span class="token number">9.</span> 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）
</code></pre></div><h2 id="_1-从浏览器接收url到开启网络请求线程"><a href="#_1-从浏览器接收url到开启网络请求线程" class="header-anchor">#</a> 1.从浏览器接收url到开启网络请求线程</h2> <div class="language-js extra-class"><pre class="language-js"><code>浏览器进程<span class="token operator">/</span>线程模型，<span class="token constant">JS</span>的运行机制

多进程的浏览器
浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）

进程可能包括主控进程，插件进程，<span class="token constant">GPU</span>，tab页（浏览器内核）等等

Browser进程：浏览器的主进程（负责协调、主控），只有一个
第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
<span class="token constant">GPU</span>进程：最多一个，用于<span class="token number">3</span>D绘制
浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）
</code></pre></div> <div class="language-js extra-class"><pre class="language-js"><code>解析<span class="token constant">URL</span>  →→→ 开启网络线程到发出一个完整的http请求（<span class="token constant">DNS</span>查询得到<span class="token constant">IP</span> ，tcp<span class="token operator">/</span>ip请求 ，再到网络层的ip寻址，
再到数据链路层的封装成帧，最后到物理层的利用物理介质传输）


输入<span class="token constant">URL</span>后，会进行解析（<span class="token constant">URL</span>的本质就是统一资源定位符）

<span class="token constant">URL</span>一般包括几大部分：
protocol，协议头，譬如有http，ftp等
host，主机域名或<span class="token constant">IP</span>地址
port，端口号
path，目录路径
query，即查询参数
fragment，即#后的hash值，一般用来定位到某个位置

主要内容包括：dns查询，tcp<span class="token operator">/</span>ip请求构建，五层因特网协议栈等等

<span class="token constant">DNS</span>查询得到<span class="token constant">IP</span>
如果输入的是域名，需要进行dns解析成<span class="token constant">IP</span>，大致流程：

如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host
如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的<span class="token constant">IP</span>
注意，域名查询时有可能是经过了<span class="token constant">CDN</span>调度器的（如果有cdn存储功能的话）
而且，需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑dns<span class="token operator">-</span>prefetch优化

tcp<span class="token operator">/</span>ip请求
http的本质就是tcp<span class="token operator">/</span>ip请求
<span class="token number">3</span>次握手规则建立连接以及断开连接时的四次挥手

</code></pre></div><h1 id="_2-服务器接收到请求到对应后台接收到请求"><a href="#_2-服务器接收到请求到对应后台接收到请求" class="header-anchor">#</a> 2.服务器接收到请求到对应后台接收到请求</h1> <div class="language-js extra-class"><pre class="language-js"><code>服务端在接收到请求时，内部会进行很多的处理

负载均衡
<span class="token function">对于大型的项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所以一般会有若干台服务器组成一个集群，然后配合反向代理实现负载均衡</span>

<span class="token punctuation">(</span>用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，
分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的<span class="token constant">HTTP</span>响应，并将它反馈给用户<span class="token punctuation">)</span>

后台的处理
一般有的后端是有统一的验证的，如安全拦截，跨域验证
如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等）
然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）
等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）
然后就是将这个包从后端发送到前端，完成交互

后台和前台的http交互
前后端交互时，http报文作为信息的载体

http报文结构
报文一般包括了：通用头部，请求<span class="token operator">/</span>响应头部，请求<span class="token operator">/</span>响应体

<span class="token number">1</span>xx——指示信息，表示请求已接收，继续处理
<span class="token number">2</span>xx——成功，表示请求已被成功接收、理解、接受
<span class="token number">3</span>xx——重定向，要完成请求必须进行更进一步的操作
<span class="token number">4</span>xx——客户端错误，请求有语法错误或请求无法实现
<span class="token number">5</span>xx——服务器端错误，服务器未能实现合法的请求

请求<span class="token operator">/</span>响应头部
Accept<span class="token operator">:</span> 接收类型，表示浏览器支持的<span class="token constant">MIME</span>类型 （对标服务端返回的Content<span class="token operator">-</span>Type）
Accept<span class="token operator">-</span>Encoding：浏览器支持的压缩类型<span class="token punctuation">,</span>如gzip等<span class="token punctuation">,</span>超出类型不能接收
Content<span class="token operator">-</span>Type：客户端发送出去实体内容的类型
Cache<span class="token operator">-</span>Control<span class="token operator">:</span> 指定请求和响应遵循的缓存机制，如no<span class="token operator">-</span>cache
If<span class="token operator">-</span>Modified<span class="token operator">-</span>Since：对应服务端的Last<span class="token operator">-</span>Modified，用来匹配看文件是否变动，只能精确到<span class="token number">1</span>s之内，http1<span class="token punctuation">.</span><span class="token number">0</span>中
Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1<span class="token punctuation">.</span><span class="token number">0</span>，而且是服务端时间
Max<span class="token operator">-</span>age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1<span class="token punctuation">.</span><span class="token number">1</span>中
If<span class="token operator">-</span>None<span class="token operator">-</span>Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1<span class="token punctuation">.</span><span class="token number">1</span>中
Cookie<span class="token operator">:</span> 有cookie并且同域访问时会自动带上
Connection<span class="token operator">:</span> 当浏览器与服务器通信时对于长连接如何进行处理<span class="token punctuation">,</span>如keep<span class="token operator">-</span>alive
Host：请求的服务器<span class="token constant">URL</span>
Origin：最初的请求是从哪里发起的（只会精确到端口）<span class="token punctuation">,</span>Origin比Referer更尊重隐私
Referer：该页面的来源<span class="token constant">URL</span><span class="token punctuation">(</span>适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段<span class="token punctuation">)</span>
User<span class="token operator">-</span>Agent：用户客户端的一些必要信息，如<span class="token constant">UA</span>头部等

常用的响应头部（部分）
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Headers<span class="token operator">:</span> 服务器端允许的请求Headers
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Methods<span class="token operator">:</span> 服务器端允许的请求方法
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin<span class="token operator">:</span> 服务器端允许的请求Origin头部（譬如为<span class="token operator">*</span>）
Content<span class="token operator">-</span>Type：服务端返回的实体内容的类型
Date：数据从服务器发送的时间
Cache<span class="token operator">-</span>Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档
Last<span class="token operator">-</span>Modified：请求资源的最后修改时间
Expires：应该在什么时候认为文档已经过期<span class="token punctuation">,</span>从而不再缓存它
Max<span class="token operator">-</span>age：客户端的本地资源应该缓存多少秒，开启了Cache<span class="token operator">-</span>Control后有效
ETag：请求变量的实体标签的当前值
Set<span class="token operator">-</span>Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端
Keep<span class="token operator">-</span>Alive：如果客户端有keep<span class="token operator">-</span>alive，服务端也会有响应（如timeout<span class="token operator">=</span><span class="token number">38</span>）
Server：服务器的一些相关信息

（请求头部和响应头部是匹配分析的。）
譬如，请求头部的Accept要和响应头部的Content<span class="token operator">-</span>Type匹配，否则会报错
譬如，跨域请求时，请求头部的Origin要匹配响应头部的Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin，否则会报跨域错误
</code></pre></div><p><img src="/assets/img/request.24c2afdb.jpg" alt="solar"></p> <h2 id="_3-浏览器内核拿到内容后-渲染步骤大致"><a href="#_3-浏览器内核拿到内容后-渲染步骤大致" class="header-anchor">#</a> 3.浏览器内核拿到内容后，渲染步骤大致</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1.</span> 解析<span class="token constant">HTML</span>，构建<span class="token constant">DOM</span>树
<span class="token number">2.</span> 解析<span class="token constant">CSS</span>，生成<span class="token constant">CSS</span>规则树
<span class="token number">3.</span> 合并<span class="token constant">DOM</span>树和<span class="token constant">CSS</span>规则，生成render树
<span class="token number">4.</span> 布局render树（Layout<span class="token operator">/</span>reflow），负责各元素尺寸、位置的计算
<span class="token number">5.</span> 绘制render树（paint），绘制页面像素信息
<span class="token number">6.</span> 浏览器会将各层的信息发送给<span class="token constant">GPU</span>，<span class="token constant">GPU</span>会将各层合成（composite），显示在屏幕上
</code></pre></div><p><img src="/assets/img/analysis.d5d98b73.jpg" alt="solar"></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">HTML</span>解析，构建<span class="token constant">DOM</span>

浏览器解析<span class="token constant">HTML</span>，构建<span class="token constant">DOM</span>树（Bytes → characters → tokens → nodes → <span class="token constant">DOM</span>）
<span class="token number">1.</span> Conversion转换：浏览器将获得的<span class="token constant">HTML</span>内容（Bytes）基于他的编码转换为单个字符
<span class="token number">2.</span> Tokenizing分词：浏览器按照<span class="token constant">HTML</span>规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集
<span class="token number">3.</span> Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则
<span class="token number">4.</span> <span class="token constant">DOM</span>构建：因为<span class="token constant">HTML</span>标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样
例如：body对象的父节点就是<span class="token constant">HTML</span>对象，然后段略p对象的父节点就是body对象

浏览器的处理如下：
</code></pre></div><p><img src="/assets/img/browser.375a470e.jpg" alt="solar"></p> <div class="language-js extra-class"><pre class="language-js"><code>渲染
render树，接下来就是开始渲染
</code></pre></div><p><img src="/assets/img/renderTree.9906dac0.jpg" alt="solar"></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1.</span> 计算<span class="token constant">CSS</span>样式
<span class="token number">2.</span> 构建渲染树
<span class="token number">3.</span> 布局，主要定位坐标和大小，是否换行，各种position overflow z<span class="token operator">-</span>index属性
<span class="token number">4.</span> 绘制，将图像绘制出来

Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树
Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等）
<span class="token function">此时只需要应用新样式绘制这个元素就可以了</span>
<span class="token punctuation">(</span>回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流<span class="token punctuation">)</span>

什么会引起回流？
<span class="token number">1.</span>页面渲染初始化
<span class="token number">2.</span><span class="token constant">DOM</span>结构改变，比如删除了某个节点
<span class="token number">3.</span>render树变化，比如减少了padding
<span class="token number">4.</span>窗口resize
<span class="token number">5.</span>最复杂的一种：获取某些属性，引发回流，
很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，
但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括
    <span class="token function">（1）offset</span><span class="token punctuation">(</span>Top<span class="token operator">/</span>Left<span class="token operator">/</span>Width<span class="token operator">/</span>Height<span class="token punctuation">)</span>
     <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token function">scroll</span><span class="token punctuation">(</span>Top<span class="token operator">/</span>Left<span class="token operator">/</span>Width<span class="token operator">/</span>Height<span class="token punctuation">)</span>
     <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token function">cilent</span><span class="token punctuation">(</span>Top<span class="token operator">/</span>Left<span class="token operator">/</span>Width<span class="token operator">/</span>Height<span class="token punctuation">)</span>
     <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> width<span class="token punctuation">,</span><span class="token function">height</span>
     <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token function">调用了getComputedStyle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>或者<span class="token constant">IE</span>的currentStyle

回流一定伴随着重绘，重绘却可以单独出现
减少逐项更改样式，最好一次性更改style，或者将样式定义为<span class="token keyword">class</span>并一次性更新
避免循环操作dom，创建一个documentFragment或div，在它上面应用所有<span class="token constant">DOM</span>操作，最后再把它添加到window<span class="token punctuation">.</span>document
避免多次读取offset等属性。无法避免则将它们缓存到变量
将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高
</code></pre></div><h2 id="资源外链的下载"><a href="#资源外链的下载" class="header-anchor">#</a> 资源外链的下载</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">在解析html时，会遇到一些资源连接</span> <span class="token punctuation">(</span><span class="token constant">CSS</span>样式资源 <span class="token constant">JS</span>脚本资源 img图片类资源 <span class="token punctuation">)</span>

外链时的处理
遇到上述的外链时，会单独开启一个下载线程去下载资源（http1<span class="token punctuation">.</span><span class="token number">1</span>中是每一个资源的下载都要开启一个http请求，对应一个tcp<span class="token operator">/</span>ip链接）

遇到<span class="token constant">CSS</span>样式资源
<span class="token constant">CSS</span>下载时异步，不会阻塞浏览器构建<span class="token constant">DOM</span>树
但是会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）
有例外，media query声明的<span class="token constant">CSS</span>是不会阻塞渲染的

遇到<span class="token constant">JS</span>脚本资源
阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析<span class="token constant">HTML</span>
浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已
defer与<span class="token keyword">async</span>，普通的脚本是会阻塞浏览器解析的，但是可以加上defer或<span class="token keyword">async</span>属性，这样脚本就变成异步了，可以等到解析完毕后再执行
注意，defer和<span class="token keyword">async</span>是有区别的： defer是延迟执行，而<span class="token keyword">async</span>是异步执行

遇到img图片类资源
遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方

loaded和domcontentloaded（简单的对比）
DOMContentLoaded 事件触发时，仅当<span class="token constant">DOM</span><span class="token function">加载完成，不包括样式表，图片</span><span class="token punctuation">(</span>譬如如果有<span class="token keyword">async</span>加载的脚本就不一定完成<span class="token punctuation">)</span>
load 事件触发时，页面上所有的<span class="token constant">DOM</span>，样式表，脚本，图片都已经加载完成了
</code></pre></div><h2 id="js引擎解析过程"><a href="#js引擎解析过程" class="header-anchor">#</a> JS引擎解析过程</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">JS</span>是解释型语音，所以它无需提前编译，而是由解释器实时运行
<span class="token number">1.</span> 读取代码，进行词法分析（Lexical analysis），然后将代码分解成词元（token）
<span class="token number">2.</span> 对词元进行语法分析（parsing），然后将代码整理成语法树（syntax tree）
<span class="token number">3.</span> 使用翻译器（translator），将代码转为字节码（bytecode）
<span class="token number">4.</span> 使用字节码解释器（bytecode interpreter），将字节码转为机器码

<span class="token constant">JS</span>的预处理阶段（变量提升，分号补全） →→→   <span class="token constant">JS</span>的执行阶段（执行上下文，执行堆栈概念） →→→   回收机制

预处理阶段：
变量提升 （包括函数提升和变量提升）

<span class="token constant">JS</span>的执行阶段：
执行上下文，执行堆栈概念（如全局上下文，当前活动上下文）
<span class="token constant">VO</span>（变量对象）和<span class="token constant">AO</span>（活动对象）
作用域链
<span class="token keyword">this</span>机制等

回收机制：
常用的两种垃圾回收规则是： （标记清除<span class="token punctuation">,</span>引用计数 ） 



</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.157a43b5.js" defer></script><script src="/assets/js/2.52866a67.js" defer></script><script src="/assets/js/6.f0062c90.js" defer></script>
  </body>
</html>
