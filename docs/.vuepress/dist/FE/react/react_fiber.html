<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React16 Fiber | aurora blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/feature_cat.jpeg">
    <meta name="description" content="我的个人网站">
    
    <link rel="preload" href="/assets/css/0.styles.cb058343.css" as="style"><link rel="preload" href="/assets/js/app.157a43b5.js" as="script"><link rel="preload" href="/assets/js/2.52866a67.js" as="script"><link rel="preload" href="/assets/js/5.cb8c9fa9.js" as="script"><link rel="prefetch" href="/assets/js/10.010d567c.js"><link rel="prefetch" href="/assets/js/11.4af4b929.js"><link rel="prefetch" href="/assets/js/12.337cdcf1.js"><link rel="prefetch" href="/assets/js/13.90875d56.js"><link rel="prefetch" href="/assets/js/14.0ed7aefb.js"><link rel="prefetch" href="/assets/js/15.754a382b.js"><link rel="prefetch" href="/assets/js/16.cb862ad8.js"><link rel="prefetch" href="/assets/js/17.4fa3dc3a.js"><link rel="prefetch" href="/assets/js/18.19362ae0.js"><link rel="prefetch" href="/assets/js/19.bb38661a.js"><link rel="prefetch" href="/assets/js/20.9f6dac92.js"><link rel="prefetch" href="/assets/js/21.b86ba564.js"><link rel="prefetch" href="/assets/js/22.08390e2a.js"><link rel="prefetch" href="/assets/js/23.07ce8733.js"><link rel="prefetch" href="/assets/js/24.2224abb3.js"><link rel="prefetch" href="/assets/js/25.cf2cacb2.js"><link rel="prefetch" href="/assets/js/26.0fab9c3d.js"><link rel="prefetch" href="/assets/js/27.409f3c11.js"><link rel="prefetch" href="/assets/js/28.2d999655.js"><link rel="prefetch" href="/assets/js/29.4c4b34f2.js"><link rel="prefetch" href="/assets/js/3.2452f598.js"><link rel="prefetch" href="/assets/js/30.c7e81ddc.js"><link rel="prefetch" href="/assets/js/31.87c49613.js"><link rel="prefetch" href="/assets/js/32.785f3b5f.js"><link rel="prefetch" href="/assets/js/33.d851ac79.js"><link rel="prefetch" href="/assets/js/34.f7dbbd6a.js"><link rel="prefetch" href="/assets/js/35.ecb758ea.js"><link rel="prefetch" href="/assets/js/36.478ee48d.js"><link rel="prefetch" href="/assets/js/37.b1e60efd.js"><link rel="prefetch" href="/assets/js/38.5b5e4eff.js"><link rel="prefetch" href="/assets/js/39.694373c0.js"><link rel="prefetch" href="/assets/js/4.e4d2375c.js"><link rel="prefetch" href="/assets/js/40.4a96b7b1.js"><link rel="prefetch" href="/assets/js/41.b0c17527.js"><link rel="prefetch" href="/assets/js/42.bb73ede6.js"><link rel="prefetch" href="/assets/js/43.dcd6c126.js"><link rel="prefetch" href="/assets/js/44.f643b2b9.js"><link rel="prefetch" href="/assets/js/45.194d68b8.js"><link rel="prefetch" href="/assets/js/46.a68230ef.js"><link rel="prefetch" href="/assets/js/47.0d19f838.js"><link rel="prefetch" href="/assets/js/48.d3f26e8c.js"><link rel="prefetch" href="/assets/js/49.b7740e4c.js"><link rel="prefetch" href="/assets/js/50.2587ca2f.js"><link rel="prefetch" href="/assets/js/51.ea8d1c82.js"><link rel="prefetch" href="/assets/js/52.48ff45db.js"><link rel="prefetch" href="/assets/js/53.218b9ecf.js"><link rel="prefetch" href="/assets/js/54.1fa58f1d.js"><link rel="prefetch" href="/assets/js/55.d2ef0ce9.js"><link rel="prefetch" href="/assets/js/56.4a7bc600.js"><link rel="prefetch" href="/assets/js/57.b442bff3.js"><link rel="prefetch" href="/assets/js/58.542150a6.js"><link rel="prefetch" href="/assets/js/6.f0062c90.js"><link rel="prefetch" href="/assets/js/7.b156b7cb.js"><link rel="prefetch" href="/assets/js/8.dfb56ee2.js"><link rel="prefetch" href="/assets/js/9.f870735d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.cb058343.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">aurora blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/sountstars" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/sountstars" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>FE框架</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>react</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/FE/react/basic.html" class="sidebar-link">react基本用法</a></li><li><a href="/FE/react/lifecycle.html" class="sidebar-link">react生命周期</a></li><li><a href="/FE/react/hook.html" class="sidebar-link">hooks 16.8版本后</a></li><li><a href="/FE/react/route.html" class="sidebar-link">Route原理</a></li><li><a href="/FE/react/react_redux.html" class="sidebar-link">Redux源码解析</a></li><li><a href="/FE/react/react_fiber.html" aria-current="page" class="active sidebar-link">React16 Fiber</a></li><li><a href="/FE/react/virtual_dom.html" class="sidebar-link">React-VirtualDOM</a></li><li><a href="/FE/react/react_event.html" class="sidebar-link">React事件委托机制</a></li><li><a href="/FE/react/sound_code.html" class="sidebar-link">/FE/react/sound_code.html</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>React-Native</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>构建工具</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Typescript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Servers</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Git命令</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Other</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react16-fiber"><a href="#react16-fiber" class="header-anchor">#</a> React16 Fiber</h1> <p></p><div class="table-of-contents"><ul><li><a href="#react16之前的痛点">React16之前的痛点</a></li><li><a href="#解决进度">解决进度</a></li><li><a href="#fiber是什么">Fiber是什么</a></li><li><a href="#关键特性">关键特性</a></li><li><a href="#为什么需要异步渲染">为什么需要异步渲染</a></li><li><a href="#fiber的结构">Fiber的结构</a></li><li><a href="#fiber-tree与workinprogress-tree">Fiber tree与workInProgress tree</a></li><li><a href="#fiber-reconciliation-更新过程">Fiber Reconciliation(更新过程)</a><ul><li><a href="#diff-render-reconciliation">diff ~ render/reconciliation</a></li><li><a href="#patch-commit">patch ~ commit</a></li></ul></li><li><a href="#为什么需要新的生命周期">为什么需要新的生命周期</a></li><li><a href="#优先级策略">优先级策略</a></li><li><a href="#参考文档">参考文档</a></li></ul></div><p></p> <p>React早期的优化都是<code>停留于JS层面</code>（vdom的 create/diff），诸如减少组件的复杂度（Stateless）， 减少向下diff的规模(SCU)，减少diff的成本(immutable.js)，当然，也有例外，比如针对老式的IE的LazyDOMTree。 到React16，则<code>升级到浏览器渲染机制层面</code>, 在patch上取得了突破。众所周知，浏览器是单线程。 想象一下，如果有两个线程，一个线程要对这节点进行移除，一个要对它进行样式操作。 线程是并发的，无法决定顺序，这样页面的效果是不可控的。换单线程则简单可控， 但JS执行与视图渲染与资原加载与事件回调是如何调度呢，于是有了EventLoop这种东西。</p> <h2 id="react16之前的痛点"><a href="#react16之前的痛点" class="header-anchor">#</a> React16之前的痛点</h2> <ul><li>组件不能返回数组</li> <li>弹窗问题</li> <li>异常处理</li> <li>HOC没有考虑到ref与context的向下传递</li> <li>组件的性能优化全凭人肉，并且主要集中在SCU，希望框架能干些事情，即使不用SCU，性能也能上去。</li></ul> <h2 id="解决进度"><a href="#解决进度" class="header-anchor">#</a> 解决进度</h2> <p>16版本大更新，Fiber顺手解决了这些痛点</p> <ul><li>16.0 让组件支持返回任何数组类型，从而解决数组问题; 推出createPortal API ,解决弹窗问题; 推出componentDidCatch新钩子， 划分出错误组件与边界组件， 每个边界组件能修复下方组件错误一次， 再次出错，转交更上层的边界组件来处理，解决异常处理问题。</li> <li>16.2 推出Fragment组件，可以看作是数组的一种语法糖。</li> <li>16.3 推出createRef与forwardRef解决Ref在HOC中的传递问题，推出new Context API，解决HOC的context传递问题</li> <li>而性能问题，从16.0开始一直由一些内部机制来保证，涉及到批量更新及基于时间分片的限量更新。
<img src="/assets/img/react_fiber_1.bb59dc24.jpg" alt="solar"></li></ul> <h2 id="fiber是什么"><a href="#fiber是什么" class="header-anchor">#</a> Fiber是什么</h2> <p><code>eact Fiber</code>是对核心算法的一次重新实现。<code>React Fiber</code>把更新过程碎片化，把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会</p> <ul><li>在React Fiber中，一次更新过程会<code>分成多个分片</code>完成，所以完全有可能一个更新任务还没有完成，就被另一个更高优先级的更新过程打断，这时候，优先级高的更新任务会优先处理完，而低优先级更新任务所做的工作则会完全作废，然后等待机会重头再来</li> <li>因为一个更新过程可能被打断，所以React Fiber一个更新过程被分为两个阶段(Phase)：第一个阶段<code>Reconciliation Phase(调度阶段)</code>和第二阶段<code>Commit Phase(渲染阶段)</code></li> <li>在<code>第一阶段Reconciliation Phase</code>，React Fiber会找出需要更新哪些DOM，这个阶段是<code>可以被打断</code>的；但是到了<code>第二阶段Commit Phase</code>，那就一鼓-作气把DOM更新完，绝<code>不会被打断</code></li> <li>这两个阶段大部分工作都是React Fiber做，和我们相关的也就是修改了部分生命周期函数</li></ul> <p>React Fiber改变了之前react的组件渲染机制，新的架构使原来同步渲染的组件现在可以异步化，可中途中断渲染，执行更高优先级的任务。释放浏览器主线程,解决掉帧的问题</p> <h2 id="关键特性"><a href="#关键特性" class="header-anchor">#</a> 关键特性</h2> <ul><li>时间分片（把渲染任务拆分成块，匀到多帧）</li> <li>更新时能够暂停，终止，复用渲染任务（链表）</li> <li>给不同类型的更新赋予优先级</li> <li>并发方面新的基础能力</li></ul> <h2 id="为什么需要异步渲染"><a href="#为什么需要异步渲染" class="header-anchor">#</a> 为什么需要异步渲染</h2> <p>我们都知道在react16之前，react对virtual dom 的渲染是同步的，即每次将所有操作累加起来，统计对比出所有的变化后，统一更新一次DOM树<a href="https://github.com/livoras/blog/issues/13" target="_blank" rel="noopener noreferrer">了解虚拟dom算法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，随着组件层级的深入，由于渲染更新一旦开始就无法停止，导致主线程长时间被占用，这也是react在动画，布局和手势等区域会有造成掉帧、延迟响应（甚至无响应）等不佳体验。</p> <p>假如更新一个组件需要1毫秒，如果有200个组件要更新，那就需要200毫秒，在这200毫秒的更新过程中，浏览器那个唯一的主线程都在专心运行更新操作，无暇去做任何其他的事情。想象一下，在这200毫秒内，用户往一个input元素中输入点什么，敲击键盘也不会获得响应，因为渲染输入按键结果也是浏览器主线程的工作，但是浏览器主线程被React占着呢，抽不出空，最后的结果就是用户敲了按键看不到反应，等React更新过程结束之后，咔咔咔那些按键一下子出现在input元素里了。</p> <h2 id="fiber的结构"><a href="#fiber的结构" class="header-anchor">#</a> Fiber的结构</h2> <p>React 目前的做法是使用<code>链表</code>, 每个 VirtualDOM 节点内部现在使用 Fiber表示, 它的结构大概如下:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> type Fiber <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// Fiber 类型信息</span>
  type<span class="token operator">:</span> any<span class="token punctuation">,</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// ⚛️ 链表结构</span>
  <span class="token comment">// 指向父节点，或者render该节点的组件</span>
  <span class="token keyword">return</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment">// 指向第一个子节点</span>
  child<span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment">// 指向下一个兄弟节点</span>
  sibling<span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Fiber中最为重要的是return、child、sibling指针，连接父子兄弟节点以构成一颗单链表Fiber树，其扁平化的单链表结构的特点<code>将以往递归遍历改为了循环遍历</code>，实现深度优先遍历不用每次都进入递归函数，重新生成什么执行上下文，变量对象，激活对象，性能当然比递归好。
<img src="/assets/img/react_fiber_2.7c680c30.jpg" alt="solar"> Fiber Reconciliation(更新过程)*</p> <h2 id="fiber-tree与workinprogress-tree"><a href="#fiber-tree与workinprogress-tree" class="header-anchor">#</a> Fiber tree与workInProgress tree</h2> <p><strong>current树</strong>:React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为<code>Virtual DOM Tree</code>，由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 <code>Fiber Node</code>，将 <code>Fiber Node</code> 链接起来的结构成为 <code>Fiber Tree</code>。它反映了用于渲染 UI 的应用程序的状态。这棵树通常被称为<code>current 树</code>（当前树，记录当前页面的状态）。</p> <p>在后续的更新过程中（setState），每次重新渲染都会<code>重新创建 Element</code>, 但是 Fiber 不会，Fiber 只会使用对应的 Element 中的数据来更新自己必要的属性</p> <p>Fiber Tree 一个重要的特点是链表结构，将递归遍历编程循环遍历，然后配合 requestIdleCallback API, 实现任务拆分、中断与恢复。</p> <p><strong>当 render 的时候有了这么一条单链表，当调用 setState 的时候又是如何 Diff 得到 change 的呢？</strong></p> <p>采用的是一种叫双缓冲技术（double buffering），这个时候就需要另外一颗树：WorkInProgress Tree，它反映了要刷新到屏幕的未来状态</p> <p><strong>workInProgress树</strong>： 当React经过<code>current当前</code>树时，对于每一个先存在的Fiber节点，它都会创建一个替代（alternate）节点，这些节点组成了workInProgress树。这个节点是使用render方法返回的React元素的数据创建的。一旦更新处理完以及所有相关工作完成，React就有一颗替代树来准备刷新屏幕。一旦这颗workInProgress树渲染（render）在屏幕上，它便成了当前树。下次进来会把current状态复制到WIP上，进行交互复用，而不用每次更新的时候都创建一个新的对象，消耗性能</p> <p>WorkInProgress Tree 构造完毕，得到的就是新的 Fiber Tree，然后喜新厌旧（把 current 指针指向WorkInProgress Tree，丢掉旧的 Fiber Tree）就好了。</p> <p>这样做的好处：</p> <ul><li>能够复用内部对象（Fiber）</li> <li>节省内存分配、GC的时间开销</li> <li>就算运行中有错误，也不会影响 View 上的数据
<img src="/assets/img/react_fiber_3.4cb9be8b.jpg" alt="solar"> <code>alternate</code> 可以理解为一个Fiber版本池，用于交替记录组件更新（切分任务后变成多阶段更新）过程中Fiber的更新，因为在组件更新的各阶段，更新前及更新过程中Fiber状态并不一致，在需要恢复时（如发生冲突），即可使用另一者直接回退至上一版本Fiber。</li></ul> <h2 id="fiber-reconciliation-更新过程"><a href="#fiber-reconciliation-更新过程" class="header-anchor">#</a> Fiber Reconciliation(更新过程)</h2> <p>react渲染大抵可以分为<strong>reconciler（调度阶段）和 commit（渲染阶段）</strong>，前者用于对比，后者用于操作dom，<code>reconciler</code>阶段可以算是一个从顶向下的递归算法，主要工作是对<code>current tree</code> 和 <code>new tree</code>做计算，找出变化部分。<code>commit</code>阶段是对在reconciler阶段获取到的变化部分应用到真实的DOM树中,在绝大部分运用场景中，reconciler阶段的时间远远超过commit，因此Fiber选择将reconciler阶段进行分割。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 第1阶段 render/reconciliation</span>
<span class="token comment">//（可中断）render/reconciliation 通过构造workInProgress tree得出change</span>
constructor
componentWillMount <span class="token comment">//废弃</span>
componentWillReceiveProps <span class="token comment">//废弃</span>
<span class="token keyword">static</span> getDerivedStateFromProps
shouldComponentUpdate
componentWillUpdate <span class="token comment">//废弃</span>
render

<span class="token comment">// 第2阶段 commit</span>
<span class="token comment">//（不可中断）commit 应用这些DOM change</span>
<span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//严格来说，这个是在进入 commit 阶段前调用</span>
componentDidMount
componentDidUpdate
componentWillUnmount
</code></pre></div><h3 id="diff-render-reconciliation"><a href="#diff-render-reconciliation" class="header-anchor">#</a> diff ~ render/reconciliation</h3> <p>diff的实际工作是对比prevInstance和nextInstance的状态，找出差异及其对应的DOM change。diff本质上是一些计算（遍历、比较），是可拆分的（算一半待会儿接着算）</p> <p>以Fiber tree为蓝本，把每个Fiber作为一个工作单元，自顶向下逐节点构造workInProgress tree（构建中的新Fiber tree）</p> <p>具体过程如下（以组件节点为例）：</p> <ol><li>如果当前节点不需要更新，直接把子节点clone过来，跳到5；要更新的话打个tag</li> <li>更新当前节点状态（props, state, context等）</li> <li>调用shouldComponentUpdate()，false的话，跳到5</li> <li>调用render()获得新的子节点，并为子节点<code>创建Fiber</code>（创建过程会尽量复用现有Fiber，子节点增删也发生在这里）</li> <li>如果没有产生child Fiber，该工作单元结束，把effect list归并到return，并把当前节点的sibling作为下一个工作单元；否则把child作为下一个工作单元</li> <li>如果没有剩余可用时间了，等到下一次主线程空闲时才开始下一个工作单元；否则，立即开始做</li> <li>如果没有下一个工作单元了（回到了workInProgress tree的根节点），第1阶段结束，进入pendingCommit状态</li></ol> <p>实际上是1-6的工作循环，7是出口，工作循环每次只做一件事，做完看要不要喘口气。工作循环结束时，workInProgress tree的根节点身上的effect list就是收集到的所有side effect（因为每做完一个都向上归并）</p> <p>所以，<strong>构建workInProgress tree的过程就是<code>diff</code>的过程</strong>，通过requestIdleCallback来调度执行一组任务，每完成一个任务后回来看看有没有插队的（更紧急的），每完成一组任务，把时间控制权交还给主线程，直到下一次requestIdleCallback回调再继续构建workInProgress tree,这部分的核心是<code>beginWork</code>函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">beginWork</span><span class="token punctuation">(</span><span class="token parameter">fiber<span class="token operator">:</span> Fiber</span><span class="token punctuation">)</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>tag <span class="token operator">===</span> WorkTag<span class="token punctuation">.</span>HostComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 宿主节点diff</span>
    <span class="token function">diffHostComponent</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>tag <span class="token operator">===</span> WorkTag<span class="token punctuation">.</span>ClassComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 类组件节点diff</span>
    <span class="token function">diffClassComponent</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>tag <span class="token operator">===</span> WorkTag<span class="token punctuation">.</span>FunctionComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 函数组件节点diff</span>
    <span class="token function">diffFunctionalComponent</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// ... 其他类型节点，省略</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="patch-commit"><a href="#patch-commit" class="header-anchor">#</a> patch ~ commit</h3> <p>第2阶段直接一口气做完：</p> <ol><li>处理effect list（更新DOM树、调用组件生命周期函数以 更新ref、异常处理等内部状态）</li> <li>出对结束，第2阶段结束，所有更新都commit到DOM树上了</li></ol> <p>注意，真的是<code>一口气做完</code>（同步执行，不能喊停）的，这个阶段的实际工作量是比较大的，所以尽量不要在后3个生命周期函数里干重活儿</p> <p>patch阶段把本次更新中的所有DOM change应用到DOM树，是一连串的DOM操作。这些DOM操作虽然看起来也可以拆分（按照change list一段一段做），但这样做一方面可能造成DOM实际状态与维护的内部状态不一致，另外还会影响体验。而且，一般场景下，DOM更新的耗时比起diff及生命周期函数耗时不算什么，拆分的意义不很大</p> <h2 id="为什么需要新的生命周期"><a href="#为什么需要新的生命周期" class="header-anchor">#</a> 为什么需要新的生命周期</h2> <p>v16之前的生命周期
<img src="/assets/img/react_fiber_4.86785079.jpg" alt="solar"></p> <ol><li>v16之前的版本，组件在<code>挂载</code>过程中会调3次钩子/方法<code>（constructor, componentWillMount, render）</code>， 组件在<code>更新</code>过程中会调4次钩子 <code>（componentWillReceiveProps, shouldUpdate, componentWillUpdate,render）</code>, updateView在check的时候很害怕出错的，总不能每个方法都用try catch包起来，这样会性能很差。而constructor, render是不可避免的，于是对三个willXXX动刀了。</li> <li>在早期版本中，<code>componentWillMount与componentWillReceiveProps</code>会做内部优化，执行多次setState都会延后到render时进行合并处理。因此用户就肆意setState了。这些willXXX还可以让用户任意操作DOM。 操作DOM会可能reflow，这是官方不愿意看到的。于是官方推出了<code>getDerivedStateFromProps</code>，让你在render设置新state，你主要返回一个新对象，它就主动帮你setState。由于这是一个静态方法，你不能操作instance，这就<code>阻止了你多次操作setState</code>。</li> <li>生命周期在React v16推出的Fiber之后就不合适了，在render函数之前的所有函数，都有可能被执行多次。 因为新的react引入了异步渲染机制，主要的功能是，在渲染完成前，可以中断任务，中断之后不会继续执行生命周期，而是重头开始执行生命周期。这导致上述的<code>componentWillMount，componentWillReceiveProps，componentWillUpdate</code>可能会被中断，导致执行多次，带来意想不到的情况。<code>如果render前执行的生命周期方法做AJAX请求的话，那AJAX将被无谓地多次调用</code></li></ol> <p><code>reconciler</code>阶段的钩子都不应该操作DOM，最好也不要setState，我们称之为<code>轻量钩子</code>。<code>commit</code>阶段的钩子则对应称之为<code>重量钩子</code></p> <p>Fiber流程图
<img src="/assets/img/react_fiber.32f54328.jpg" alt="solar"></p> <h2 id="优先级策略"><a href="#优先级策略" class="header-anchor">#</a> 优先级策略</h2> <p>每个工作单元运行时有6种优先级：</p> <ul><li>synchronous 与之前的Stack reconciler操作一样，同步执行</li> <li>task 在next tick之前执行</li> <li>animation 下一帧之前执行</li> <li>high 在不久的将来立即执行</li> <li>low 稍微延迟（100-200ms）执行也没关系</li> <li>offscreen 下一次render时或scroll时才执行</li></ul> <p><code>synchronous</code>首屏（首次渲染）用，要求尽量快，不管会不会阻塞UI线程。<code>animation</code>通过requestAnimationFrame来调度，这样在下一帧就能立即开始动画过程；后3个都是由requestIdleCallback回调执行的；offscreen指的是当前隐藏的、屏幕外的（看不见的）元素</p> <h2 id="参考文档"><a href="#参考文档" class="header-anchor">#</a> 参考文档</h2></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/FE/react/react_redux.html" class="prev">
        Redux源码解析
      </a></span> <span class="next"><a href="/FE/react/virtual_dom.html">
        React-VirtualDOM
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.157a43b5.js" defer></script><script src="/assets/js/2.52866a67.js" defer></script><script src="/assets/js/5.cb8c9fa9.js" defer></script>
  </body>
</html>
