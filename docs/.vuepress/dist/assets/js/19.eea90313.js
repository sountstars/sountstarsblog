(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{403:function(a,e,s){a.exports=s.p+"assets/img/hot.8d663eb7.jpg"},461:function(a,e,s){"use strict";s.r(e);var t=s(46),r=Object(t.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"webpack面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack面试题"}},[a._v("#")]),a._v(" webpack面试题")]),a._v(" "),t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#构建流程是什么-从读取配置到输出文件这个过程"}},[a._v("构建流程是什么?从读取配置到输出文件这个过程")])]),t("li",[t("a",{attrs:{href:"#编写loader或plugin的思路"}},[a._v("编写loader或plugin的思路")])]),t("li",[t("a",{attrs:{href:"#webpack的热更新是如何做到的"}},[a._v("webpack的热更新是如何做到的")])]),t("li",[t("a",{attrs:{href:"#提高webpack的构建速度"}},[a._v("提高webpack的构建速度")])]),t("li",[t("a",{attrs:{href:"#提高webpack的构建速度"}},[a._v("提高webpack的构建速度")])])])]),t("p"),a._v(" "),t("ul",[t("li",[a._v("webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件")]),a._v(" "),t("li",[a._v("不同的Loader来处理不同的文件，用Plugin来扩展webpack功能")])]),a._v(" "),t("h3",{attrs:{id:"构建流程是什么-从读取配置到输出文件这个过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构建流程是什么-从读取配置到输出文件这个过程"}},[a._v("#")]),a._v(" 构建流程是什么?从读取配置到输出文件这个过程")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[a._v("Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：\n"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1.")]),a._v("初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；\n"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2.")]),a._v("开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；\n"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("3.")]),a._v("确定入口：根据配置中的 entry 找出所有的入口文件；\n"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("4.")]),a._v("编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；\n"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("5.")]),a._v("完成模块编译：在经过第"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),a._v("步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；\n"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("6.")]),a._v("输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；\n"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("7.")]),a._v("输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。\n")])])]),t("h3",{attrs:{id:"编写loader或plugin的思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编写loader或plugin的思路"}},[a._v("#")]),a._v(" 编写loader或plugin的思路")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[a._v("Loader像一个"),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"翻译官"')]),a._v("把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。\n\n编写Loader时要遵循单一原则，每个Loader只做一种"),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"转义"')]),a._v("工作。\n每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("callback")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("方法，将内容返回给webpack。\n还可以通过 "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("async")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("生成一个callback函数，再用这个callback将处理后的内容输出出去。\n此外webpack还为开发者准备了开发loader的工具函数集——loader"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("utils。相对于Loader而言，Plugin的编写就灵活了许多。\nwebpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("API")]),a._v(" 改变输出结果。\n")])])]),t("h3",{attrs:{id:"webpack的热更新是如何做到的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack的热更新是如何做到的"}},[a._v("#")]),a._v(" webpack的热更新是如何做到的")]),a._v(" "),t("p",[t("img",{attrs:{src:s(403),alt:"solar"}})]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[a._v("首先要知道server端和client端都做了处理工作\n"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1.")]),a._v("第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，\n根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。\n"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2.")]),a._v("第二步是 webpack"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("dev"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("server 和 webpack 之间的接口交互，而在这一步，主要是 dev"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("server 的中间件 webpack"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("dev"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("middleware 和\n webpack 之间的交互，webpack"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("dev"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("middleware 调用 webpack 暴露的 "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("API")]),a._v("对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。\n"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("3.")]),a._v("第三步是 webpack"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("dev"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("watchContentBase 为 "),t("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("true")]),a._v(" 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。\n注意，这儿是浏览器刷新，和 "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("HMR")]),a._v(" 是两个概念。\n"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("4.")]),a._v("第四步也是 webpack"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("dev"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("server 代码的工作，该步骤主要是通过 sockjs（webpack"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("dev"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("server 的依赖）在浏览器端和服务端之间建立一个 websocket \n长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket \n消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。\n"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("5.")]),a._v("webpack"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("dev"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("server"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("hot"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("dev"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("server\n 的工作就是根据 webpack"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("dev"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("server"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("client 传给它的信息以及 dev"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，\n 也就没有后面那些步骤了。\n"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("6.")]),a._v("HotModuleReplacement"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("runtime 是客户端 "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("HMR")]),a._v(" 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("runtime\n 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，\n 获取到最新的模块代码。这就是上图中 "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("7")]),a._v("、"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("8")]),a._v("、"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("9")]),a._v(" 步骤。\n"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("7.")]),a._v("而第 "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),a._v(" 步是决定 "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("HMR")]),a._v(" 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，\n检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。\n"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("8.")]),a._v("最后一步，当 "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("HMR")]),a._v(" 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。\n")])])]),t("h3",{attrs:{id:"提高webpack的构建速度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#提高webpack的构建速度"}},[a._v("#")]),a._v(" 提高webpack的构建速度")]),a._v(" "),t("ul",[t("li",[a._v("压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的"),t("code",[a._v("UglifyJsPlugin")]),a._v("和"),t("code",[a._v("ParallelUglifyPlugin")]),a._v("来压缩JS文件， 利用"),t("code",[a._v("cssnano")]),a._v("（css-loader?minimize）来压缩css")]),a._v(" "),t("li",[a._v("利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于"),t("code",[a._v("output")]),a._v("参数和各loader的"),t("code",[a._v("publicPath")]),a._v("参数来修改资源路径")]),a._v(" "),t("li",[a._v("删除死代码（"),t("code",[a._v("Tree Shaking")]),a._v("）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数"),t("code",[a._v("--optimize-minimize")]),a._v("来实现")]),a._v(" "),t("li",[a._v("提取公共代码。")])]),a._v(" "),t("h3",{attrs:{id:"提高webpack的构建速度-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#提高webpack的构建速度-2"}},[a._v("#")]),a._v(" 提高webpack的构建速度")]),a._v(" "),t("ul",[t("li",[a._v("多入口情况下，使用"),t("code",[a._v("CommonsChunkPlugin")]),a._v("来提取公共代码")]),a._v(" "),t("li",[a._v("通过"),t("code",[a._v("externals")]),a._v("配置来提取常用库")]),a._v(" "),t("li",[a._v("利用"),t("code",[a._v("DllPlugin")]),a._v("和"),t("code",[a._v("DllReferencePlugin")]),a._v("预编译资源模块 通过"),t("code",[a._v("DllPlugin")]),a._v("来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过"),t("code",[a._v("DllReferencePlugin")]),a._v("将预编译的模块加载进来。")]),a._v(" "),t("li",[a._v("使用"),t("code",[a._v("Happypack")]),a._v("实现多线程加速编译")]),a._v(" "),t("li",[a._v("使用"),t("code",[a._v("webpack-uglify-parallel")]),a._v("来提升uglifyPlugin的压缩速度。 原理上"),t("code",[a._v("webpack-uglify-parallel")]),a._v("采用了多核并行压缩来提升压缩速度")]),a._v(" "),t("li",[a._v("使用"),t("code",[a._v("Tree-shaking")]),a._v("和"),t("code",[a._v("Scope Hoisting")]),a._v("来剔除多余代码")])])])}),[],!1,null,null,null);e.default=r.exports}}]);